#pragma data_seg(push, ".shaders")
const char * _shaders[] = {
	{ "#version 430\nuniform float time; /* time */\nuniform vec3 lightd; // light direction\nuniform vec3 lightc; // light color\n" },
	{ "\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * 1024 + gid.x;	colors[index] = vec4(gid.x / 1024.f, 0.f, gid.y / 1024.f, 1.f);}" },
	{ "//\n// GLSL textureless classic 2D noise cnoise,\n// with an RSL-style periodic variant pnoise.\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\nvec4 mod289(vec4 x)\n{\n	return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x)\n{\n	return mod289(((x*34.0) + 1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{\n	return 1.79284291400159 - 0.85373472095314 * r;}\nvec2 fade(vec2 t) {\n	return t*t*t*(t*(t*6.0 - 15.0) + 10.0);}\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod289(Pi); // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n	Pi = mod289(Pi);        // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n" },
	{ "\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * 1024 + gid.x;	colors[index] = vec4(gid.x / 1024.f, 0.f, gid.y / 1024.f, 1.f);}" },
	{ "in vec3 p;in vec3 n;out vec4 o;uniform vec3 cp;const float specular_contribution = 0.15f;const float n2 = 1.4; // water index\nvoid main() {\n	vec3 incident = normalize(p - cp);	vec3 normal = normalize(n);	float reflect_dot = dot(incident, normal);	vec3 rd_out = incident - 2.f * reflect_dot * normal;	vec3 reflect_color = sky_color(p, rd_out);	// Fresnel equations:\n	vec3 refraction = normalize(refract(incident, normal, 1.f/n2));	float incident_cos = dot(incident, normal);	float refract_cos = dot(refraction, normal);	float reflectance = clamp(pow((incident_cos - n2*refract_cos) / (incident_cos + refract_cos), 2.f), 0.f, 1.f);	float spec = clamp(reflect_dot, 0.f, 1.f)*2.f;	vec3 refract_color = vec3(0.f, 0.3, 0.5);	o.rgb = mix(refract_color, reflect_color, reflectance);	// Specular:\n	float d = clamp(dot(normal, lightd), 0.f, 1.f);	o.rgb += d * lightc * spec;	o.a = 1.f;}" },
	{ "#version 430\nlayout (location = 0) in vec4 v;layout(location = 1) in int i; //index into buffers\nout vec3 p;out vec3 n;uniform mat4 PV; // projection matrix\nuniform mat4 M; // model matrix\nuniform mat4 V;layout(std140, binding = 0) buffer a { // ocean data\n	vec4 ov[];};layout(std140, binding = 1) buffer b { // displacement\n	vec2 dp[];};void main() {\n	vec4 ocean_value = ov[i];	vec2 d = dp[i];	vec4 pos = v;	pos.y += ocean_value.a;	pos.xz += d;	// TODO: Model matrix\n	mat3 normal_matrix = transpose(inverse(mat3(V)));	p = pos.xyz;	gl_Position = PV*pos;	n = normalize(normal_matrix * ocean_value.rgb);}" },
	{ "#define NEAR_Z 0.0f\n#define FAR_Z 250.0f\n#define STEP_SIZE 0.03f\n#define STEP_SIZE2 0.03f\n#define TEXTURE_SCALE 0.001f\n#define CLOUD_OFFSET 52.0\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\nfloat noise(in vec3 x)\n{\n	vec3 p = floor(x);	vec3 f = fract(x);	f = f*f*(3.0 - 2.0*f);	float n = p.x + p.y*157.0 + 113.0*p.z;	return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n		mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n		mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n		mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);}\nfloat map5(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q); q = q*2.03;	f += 0.12500*noise(q); q = q*2.01;	f += 0.06250*noise(q); q = q*2.02;	f += 0.03125*noise(q);	return clamp(1.5 - abs(p.y - CLOUD_OFFSET) - 2.0 + 1.75*f, 0.0, 1.0);}\nfloat map4(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q); q = q*2.03;	f += 0.12500*noise(q); q = q*2.01;	f += 0.06250*noise(q);	return clamp(1.5 - abs(p.y - CLOUD_OFFSET + 0.5) - 2.0 + 1.75*f, 0.0, 1.0);}\nfloat map3(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q); q = q*2.03;	f += 0.12500*noise(q);	return clamp(1.5 - abs(p.y - CLOUD_OFFSET - 0.5) - 2.0 + 1.75*f, 0.0, 1.0);}\nfloat map2(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q);;	return clamp(1.5 - abs(p.y - CLOUD_OFFSET) - 2.0 + 1.75*f, 0.0, 1.0);}\nvec3 sundir = normalize(vec3(-1.0, 0.0, -1.0));vec4 integrate(in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t)\n{\n	// lighting\n	vec3 lin = vec3(0.65, 0.68, 0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*dif;	vec4 col = vec4(mix(1.15*vec3(1.0, 0.95, 0.8), vec3(0.65), den), den);	col.xyz *= lin;	col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.003*t*t));	// front to back blending\n	col.a *= 0.4;	col.rgb *= col.a;	return sum + col*(1.0 - sum.a);}\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y > (CLOUD_OFFSET+15.0) || pos.y < (CLOUD_OFFSET-15.0) || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.1,0.02*t); }\nvec4 raymarch(in vec3 ro, in vec3 rd, in vec3 bgcol)\n{\n	vec4 sum = vec4(0.0);	float t = 0.0;	MARCH(30,map5);	MARCH(30, map4);	MARCH(30,map3);	MARCH(30,map2);	return clamp(sum, 0.0, 1.0);}\nvec3 sky_color(vec3 ro, vec3 rd){\n	// background sky\n	float sun = clamp(dot(sundir, rd), 0.0, 1.0);	vec3 col = vec3(0.6, 0.71, 0.75) - rd.y*0.2*vec3(1.0, 0.5, 1.0) + 0.15*0.5;	col += 0.2*vec3(1.0, .6, 0.1)*pow(sun, 8.0);	// clouds\n	vec4 res = raymarch(ro, rd, col);	col = col*(1.0 - res.w) + res.xyz;	// sun glare\n	col += 0.1*vec3(1.0, 0.4, 0.2)*pow(sun, 3.0);	return col;}\n" },
	{ "uniform mat4 PV;in vec2 p; /* screen position (-1, 1) */\nin vec3 cp; /* camera position (worldspace) */\nin vec3 cd; /* camera direction */\nout vec4 oc;/**\n* Return camera origin given current time.\n*/\nvec3 camera_origin(){\n	return vec3(10, 50, 100 + time);}\n/**\n* Return camera direction given current time.\n*/\nvec3 camera_direction(){\n	return cd;	/*\n	const float t = time * 0.1;	const float yaw = 1;	const float pitch = -0.1;	return vec3(-cos(pitch) * sin(yaw), sin(pitch), cos(pitch) * cos(yaw));	*/\n}\n/**\n* Generate ray based on camera direction.\n*/\nvec3 generate_ray(vec3 dir){\n	vec3 u = vec3(0, 1, 0);	vec3 r = cross(u, dir);	return normalize(u * p.y + r * p.x + dir);}\nvoid main() {\n	vec3 d = camera_direction();                             /* camera direction */\n	vec3 ro = camera_origin();                                /* ray origin */\n	vec3 rd = generate_ray(d);                                /* ray direction */\n	vec3 hit;	oc.rgb = sky_color(ro, rd);	oc.a = 1.f;	vec4 pv_hit = PV * vec4(hit, 1.f);	gl_FragDepth = (pv_hit.z / pv_hit.w);}" },
	{ "layout (location=0) in vec2 ip;uniform mat4 PV;out vec2 p;out vec3 cp; // camera pos\nout vec3 cd; // camera dir\nvoid main(){\n	p = ip;	gl_Position =  vec4(ip, 0.0, 1.0);	\n	vec4 tmp = PV * vec4(0.f, 0.f, 0.f, 1.f);	cp = tmp.xyz / tmp.w;	tmp = PV * vec4(0.f, 0.f, 1.f, 0.f);	cd = tmp.xyz / tmp.w;}" },
	{ "in vec2 p; /* screen position (-1, 1) */\nlayout(binding=0) uniform sampler2D t;out vec4 oc;void main() {\n	vec2 uv = (p + 1.)/2.;	oc = texture(t, uv);}" },
};
#pragma data_seg(pop)
