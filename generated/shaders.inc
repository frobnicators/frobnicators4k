#pragma data_seg(push, ".shaders")
const char * _shaders[] = {
	{ "#version 430\nuniform float time; /* time */\n" },
	{ "\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * 1024 + gid.x;	colors[index] = vec4(gid.x / 1024.f, 0.f, gid.y / 1024.f, 1.f);}" },
	{ "//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\nvec4 mod289(vec4 x)\n{\n	return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x)\n{\n	return mod289(((x*34.0) + 1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{\n	return 1.79284291400159 - 0.85373472095314 * r;}\nvec2 fade(vec2 t) {\n	return t*t*t*(t*(t*6.0 - 15.0) + 10.0);}\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod289(Pi); // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n	Pi = mod289(Pi);        // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n" },
	{ "\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * 1024 + gid.x;	colors[index] = vec4(gid.x / 1024.f, 0.f, gid.y / 1024.f, 1.f);}" },
	{ "#version 430\nin vec3 n;in float h;out vec4 o;void main() {\n	o.rgb = n;	o.a = 1.f;// h;}" },
	{ "#version 430\nlayout (location = 0) in vec4 v;layout(location = 1) in int i; //index into buffers\nout vec3 n;out float h;uniform mat4 PV; // projection matrix\nuniform mat4 M; // projection matrix\nlayout(std140, binding = 0) buffer a { // ocean data\n	vec4 ov[];};layout(std140, binding = 1) buffer b { // displacement\n	vec2 dp[];};void main() {\n	vec4 ocean_value = ov[i];	vec2 d = dp[i];	vec4 pos = v;	pos.y += ocean_value.a;	pos.xz += d;	gl_Position =  M*pos;	n = ocean_value.rgb;	h = ocean_value.a;}" },
	{ "/*\nbool terrainmarch(vec3 ro, vec3 rd, out vec3 hit, out float h){\n	for (float t = NEAR_Z; t < FAR_Z; t += STEP_SIZE){\n		const vec3 p = ro + rd*t;		h = ocean_height(p.xz);		if (p.y < h ){\n			hit = p;			return true;		}\n	}\n	return false;}\nvec3 ocean_color(vec3 ro, vec3 rd, vec3 hit, float h){\n	vec3 normal = normalize(texture2D(texture0, hit.xz * 0.001).rgb);	//return .5f*(normal + 1.f);	vec3 rd_out = reflect(rd, normal);	return sky_color(hit, rd_out);}\n*/\nvec3 sky_color(vec3 ro, vec3 rd){\n	const vec3 sky   = vec3(0.32, 0.58, 0.74);	const vec3 cloud = vec3(1.0, 0.95, 1.0);	const vec2 sc = ro.xz + rd.xz*(1000.0 - ro.y) / rd.y;	vec3 color = mix(sky * (1.0 - rd.y), cloud, 0.5*smoothstep(0.1f, 0.7f, cnoise(sc*0.001)));	return mix(color, sky, pow(1.0 - max(rd.y, 0.0), 8.0));}\n" },
	{ "#define NEAR_Z 0.0f\n#define FAR_Z 250.0f\n#define STEP_SIZE 0.03f\nin vec2 p; /* screen position (-1, 1) */\nout vec3 oc;/**\n* Return camera origin given current time.\n*/\nvec3 camera_origin(){\n	return vec3(10, 50, 100);}\n/**\n* Return camera direction given current time.\n*/\nvec3 camera_direction(){\n	const float t = time * 0.1;	const float yaw = 1;	const float pitch = -0.1;	return vec3(-cos(pitch) * sin(yaw), sin(pitch), cos(pitch) * cos(yaw));}\n/**\n* Generate ray based on camera direction.\n*/\nvec3 generate_ray(vec3 dir){\n	vec3 u = vec3(0, 1, 0);	vec3 r = cross(u, dir);	return normalize(u * p.y + r * p.x + dir);}\nvoid main() {\n	vec2 uv = (p + 1.)/2.;	vec3 d = camera_direction();                             /* camera direction */\n	vec3 ro = camera_origin();                                /* ray origin */\n	vec3 rd = generate_ray(d);                                /* ray direction */\n	vec3 hit;	float h;	//if (terrainmarch(ro, rd, hit, h)){\n	//	oc = ocean_color(ro, rd, hit, h);	//}\n	//else {\n		oc = sky_color(ro, rd);	//}\n	//oc = texture(texture0, uv).aaa;}" },
	{ "layout (location=0) in vec2 ip;out vec2 p;out vec3 ro;out vec3 rd;void main(){\n	float speed = 1.;	if(time > 33.) speed = 2.;	if(time > 58.) speed = 5.;	if(time > 65.) speed = 7.;	\n	p = ip;	gl_Position =  vec4(ip, 0.0, 1.0);	vec3 r = gl_Position.xyz * vec3(1.78, 1.0, 0) + vec3(0, 0, -1);	ro = vec3(0, 0, -5+time*speed);	rd = vec3(r.x, r.y, -r.z);}" },
	{ "in vec2 p; /* screen position (-1, 1) */\nlayout(binding=0) uniform sampler2D t;out vec3 oc;void main() {\n	vec2 uv = (p + 1.)/2.;	oc = texture(t, uv).rgb;}" },
};
#pragma data_seg(pop)
