#pragma data_seg(push, ".shaders")
const char * _shaders[] = {
	{ "#version 430\nuniform float time; /* time */\nuniform vec3 lightd; // light direction\nuniform vec3 lightc; // light color" },
	{ "#version 430\nlayout(std430, binding = 0) buffer a{\n	vec2 T[];};// Bit reversal buffer\nlayout(std430, binding = 1) buffer b{\n	uint R[];};layout(std430, binding = 2) buffer c{\n	vec2 buffer1[];};layout(std430, binding = 3) buffer d{\n	vec2 buffer2[];};uniform int w; // which\nuniform ivec2 wi; // w & invert\nuniform ivec2 os; // offset & stride\nlayout(local_size_x = 16, local_size_y = 1, local_size_z = 2) in;void main() {\n	uint gid = gl_GlobalInvocationID.x;	uint line = gl_GlobalInvocationID.y;	uint s = gl_LocalInvocationID.z; // 0 or 1\n	int p2w = int(pow(2.f, wi.x));	uint t_offset = gid%p2w;	uint row = gid / p2w;	uint offset = 2 * p2w * row + p2w*s + (gid % p2w);	uint index1 = offset;	uint tmp = offset;	uint index2 = s == 0 ? offset + p2w : offset - p2w;	if (wi.y == 1) {\n		index1 = R[index1];		index2 = R[index2];	}\n	offset = offset * os.y + os.x*line;	index1 = index1 * os.y + os.x*line;	index2 = index2 * os.y + os.x*line;	vec2 i1, i2;	if (w == 1) {\n		i1 = buffer1[index1];		i2 = buffer1[index2];	} else {\n		i1 = buffer2[index1];		i2 = buffer2[index2];	}\n	vec2 res;	if (s == 0) {\n		res = i1 + cmul(i2, T[t_offset]);	} else {\n		res = i2 - cmul(i1, T[t_offset]);	}\n	if (w == 1) {\n		buffer2[offset] = res;	} else {\n		buffer1[offset] = res;	}\n}" },
	{ "vec2 cmul(vec2 c1, vec2 c2) {\n	return vec2(c1.x*c2.x - c1.y * c2.y, c1.y * c2.x + c1.x * c2.y);}\n" },
	{ "//\n// GLSL textureless classic 2D noise cnoise,\n// with an RSL-style periodic variant pnoise.\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\nvec4 mod289(vec4 x)\n{\n	return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x)\n{\n	return mod289(((x*34.0) + 1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{\n	return 1.79284291400159 - 0.85373472095314 * r;}\nvec2 fade(vec2 t) {\n	return t*t*t*(t*(t*6.0 - 15.0) + 10.0);}\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod289(Pi); // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n	Pi = mod289(Pi);        // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n" },
	{ "// h~0\nlayout(std430, binding = 5) buffer b6{\n	vec2 ht0[];};layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * N + gid.x;	vec2 htilde = ht[index] * sgn;	vec2 htilde_slopex = htsx[index] * sgn;	vec2 htilde_slopez = htsz[index] * sgn;	vec2 htilde_dx = htdx[index] * sgn;	vec2 htilde_dz = htdz[index] * sgn;	vec3 normal = normalize(vec3(-htilde_slopex.x, 1.f, -htilde_slopez.x));	//od[index].xyz = normal;	//od[index].w = htilde.x;	\n	//dp[index].x = htilde_dx.x * lambda;	//dp[index].y = htilde_dz.x * lambda;}" },
	{ "#version 430\n// h~\nlayout(std430, binding = 0) buffer b1{\n	vec2 ht[];};//h~slopex\nlayout(std430, binding = 1) buffer b2{\n	vec2 htsx[];};//h~slopey\nlayout(std430, binding = 2) buffer b3{\n	vec2 htsz[];};//h~dy\nlayout(std430, binding = 3) buffer b4{\n	vec2 htdx[];};//h~dy\nlayout(std430, binding = 4) buffer b5{\n	vec2 htdz[];};uniform int N;" },
	{ "in vec3 p;in vec3 n;out vec4 o;uniform vec3 cp;const float specular_contribution = 0.15f;const float n2 = 1.4; // water index\nconst vec3 SEA_BASE = vec3(0.1, 0.19, 0.22);const vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);const vec3 SEA_REFLECT_COLOR = vec3(0.6, 0.7, 0.8);float diffuse(vec3 normal, vec3 l, float p) {\n	return pow(dot(normal, l) * 0.4 + 0.6, p);}\nfloat specular(vec3 n, vec3 l, vec3 e, float s) {\n	float nrm = (s + 8.0) / (3.1415 * 8.0);	return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;}\nvoid main() {\n	vec3 incident = normalize(p - cp);	vec3 normal = normalize(n);	float reflect_dot = dot(incident, normal);	vec3 rd_out = incident - 2.f * reflect_dot * normal;	vec3 reflect_color = sky_color(p, rd_out);// *SEA_REFLECT_COLOR;	// Fresnel equations:\n	vec3 refraction = normalize(refract(incident, normal, 1.f/n2));	float incident_cos = dot(incident, normal);	float refract_cos = dot(refraction, normal);	float reflectance = clamp(pow((incident_cos - n2*refract_cos) / (incident_cos + refract_cos), 2.f), 0.f, 1.f);	float fresnel = 1.0 - max(dot(normal, -incident), 0.0);	fresnel = pow(fresnel, 3.0) * 0.65;	vec3 refract_color = SEA_BASE + diffuse(normal, lightd, 80.0) * SEA_WATER_COLOR * 0.12;	o.rgb = mix(refract_color, reflect_color, fresnel);	// Specular:\n	//float d = clamp(dot(normal, lightd), 0.f, 1.f);	//o.rgb += d * lightc * spec;	o.a = 1.f;}" },
	{ "// ocean data\nlayout(std430, binding = 5) buffer b6{\n	vec4 od[];};// displacement\nlayout(std430, binding = 6) buffer b7{\n	vec2 dp[];};const float lambda = -0.5f;const vec2 signs = vec2(1.f, -1.f);layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * N + gid.x;	float sgn = signs[(gid.x + gid.y) & 1];	vec2 htilde = ht[index] * sgn;	vec2 htilde_slopex = htsx[index] * sgn;	vec2 htilde_slopez = htsz[index] * sgn;	vec2 htilde_dx = htdx[index] * sgn;	vec2 htilde_dz = htdz[index] * sgn;	vec3 normal = normalize(vec3(-htilde_slopex.x, 1.f, -htilde_slopez.x));	od[index].xyz = normal;	od[index].w = htilde.x;	\n	dp[index].x = htilde_dx.x * lambda;	dp[index].y = htilde_dz.x * lambda;}" },
	{ "#version 430\nlayout (location = 0) in vec4 v;layout(location = 1) in int i; //index into buffers\nout vec3 p;out vec3 n;uniform mat4 PV; // projection matrix\nuniform mat4 M; // model matrix\nuniform mat4 V;layout(std430, binding = 0) buffer a { // ocean data\n	vec4 ov[];};layout(std430, binding = 1) buffer b { // displacement\n	vec2 dp[];};void main() {\n	vec4 ocean_value = ov[i];	vec2 d = dp[i];	vec4 pos = M*v;	pos.y += ocean_value.a;	pos.xz += d;	// TODO: Model matrix\n	mat3 normal_matrix = transpose(inverse(mat3(V)));	p = pos.xyz;	gl_Position = PV*pos;	n = normalize(normal_matrix * ocean_value.rgb);}" },
	{ "#define NEAR_Z 0.0f\n#define FAR_Z 250.0f\n#define STEP_SIZE 0.03f\n#define STEP_SIZE2 0.03f\n#define TEXTURE_SCALE 0.001f\n#define CLOUD_OFFSET 52.0\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\nfloat noise(in vec3 x)\n{\n	vec3 p = floor(x);	vec3 f = fract(x);	f = f*f*(3.0 - 2.0*f);	float n = p.x + p.y*157.0 + 113.0*p.z;	return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n		mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n		mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n		mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);}\nfloat map5(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q); q = q*2.03;	f += 0.12500*noise(q); q = q*2.01;	f += 0.06250*noise(q); q = q*2.02;	f += 0.03125*noise(q);	return clamp(1.5 - abs(p.y - CLOUD_OFFSET) - 2.0 + 1.75*f, 0.0, 1.0);}\nfloat map4(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q); q = q*2.03;	f += 0.12500*noise(q); q = q*2.01;	f += 0.06250*noise(q);	return clamp(1.5 - abs(p.y - CLOUD_OFFSET + 0.5) - 2.0 + 1.75*f, 0.0, 1.0);}\nfloat map3(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q); q = q*2.03;	f += 0.12500*noise(q);	return clamp(1.5 - abs(p.y - CLOUD_OFFSET - 0.5) - 2.0 + 1.75*f, 0.0, 1.0);}\nfloat map2(in vec3 p)\n{\n	vec3 q = p - vec3(0.0, 0.1, 1.0)*time;	float f;	f = 0.50000*noise(q); q = q*2.02;	f += 0.25000*noise(q);;	return clamp(1.5 - abs(p.y - CLOUD_OFFSET) - 2.0 + 1.75*f, 0.0, 1.0);}\nvec3 sundir = normalize(vec3(-1.0, 0.0, -1.0));vec4 integrate(in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t)\n{\n	// lighting\n	vec3 lin = vec3(0.65, 0.68, 0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*dif;	vec4 col = vec4(mix(1.15*vec3(1.0, 0.95, 0.8), vec3(0.65), den), den);	col.xyz *= lin;	col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.003*t*t));	// front to back blending\n	col.a *= 0.4;	col.rgb *= col.a;	return sum + col*(1.0 - sum.a);}\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y > (CLOUD_OFFSET+15.0) || pos.y < (CLOUD_OFFSET-15.0) || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.1,0.02*t); }\nvec4 raymarch(in vec3 ro, in vec3 rd, in vec3 bgcol)\n{\n	vec4 sum = vec4(0.0);	float t = 0.0;	MARCH(30,map5);	MARCH(30, map4);	MARCH(30,map3);	MARCH(30,map2);	return clamp(sum, 0.0, 1.0);}\nvec3 sky_color(vec3 ro, vec3 rd){\n	// background sky\n	float sun = clamp(dot(sundir, rd), 0.0, 1.0);	vec3 col = vec3(0.6, 0.71, 0.75) - rd.y*0.2*vec3(1.0, 0.5, 1.0) + 0.15*0.5;	col += 0.2*vec3(1.0, .6, 0.1)*pow(sun, 8.0);	// clouds\n	vec4 res = raymarch(ro, rd, col);	col = col*(1.0 - res.w) + res.xyz;	// sun glare\n	col += 0.1*vec3(1.0, 0.4, 0.2)*pow(sun, 3.0);	return col;}\n" },
	{ "uniform mat4 PV;in vec2 p; /* screen position (-1, 1) */\nin vec3 cp; /* camera position (worldspace) */\nin vec3 cd; /* camera direction */\nout vec4 oc;/**\n* Return camera origin given current time.\n*/\nvec3 camera_origin(){\n	return vec3(10, 50, 100 + time);}\n/**\n* Return camera direction given current time.\n*/\nvec3 camera_direction(){\n	return cd;	/*\n	const float t = time * 0.1;	const float yaw = 1;	const float pitch = -0.1;	return vec3(-cos(pitch) * sin(yaw), sin(pitch), cos(pitch) * cos(yaw));	*/\n}\n/**\n* Generate ray based on camera direction.\n*/\nvec3 generate_ray(vec3 dir){\n	vec3 u = vec3(0, 1, 0);	vec3 r = cross(u, dir);	return normalize(u * p.y + r * p.x + dir);}\nvoid main() {\n	vec3 d = camera_direction();                             /* camera direction */\n	vec3 ro = camera_origin();                                /* ray origin */\n	vec3 rd = generate_ray(d);                                /* ray direction */\n	vec3 hit;	oc.rgb = sky_color(ro, rd);	oc.a = 1.f;	vec4 pv_hit = PV * vec4(hit, 1.f);	gl_FragDepth = (pv_hit.z / pv_hit.w);}" },
	{ "layout (location=0) in vec2 ip;uniform mat4 PV;out vec2 p;out vec3 cp; // camera pos\nout vec3 cd; // camera dir\nvoid main(){\n	p = ip;	gl_Position =  vec4(ip, 0.0, 1.0);	\n	vec4 tmp = PV * vec4(0.f, 0.f, 0.f, 1.f);	cp = tmp.xyz / tmp.w;	tmp = PV * vec4(0.f, 0.f, 1.f, 0.f);	cd = tmp.xyz / tmp.w;}" },
	{ "in vec2 p; /* screen position (-1, 1) */\nlayout(binding=0) uniform sampler2D t;out vec4 oc;void main() {\n	vec2 uv = (p + 1.)/2.;	oc = texture(t, uv);}" },
};
#pragma data_seg(pop)
