#pragma data_seg(push, ".shaders")
const char * _shaders[] = {
	{ "#version 430\nuniform float time; /* time */\nlayout(binding = 0)  uniform sampler2D texture0;const int ocean_size = 128;layout(std140, binding = 1) buffer ComputeOutput {\n	vec4 colors[];};//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\nvec4 mod289(vec4 x)\n{\n	return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x)\n{\n	return mod289(((x*34.0) + 1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{\n	return 1.79284291400159 - 0.85373472095314 * r;}\nvec2 fade(vec2 t) {\n	return t*t*t*(t*(t*6.0 - 15.0) + 10.0);}\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod289(Pi); // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);	Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n	Pi = mod289(Pi);        // To avoid truncation effects in permutation\n	vec4 ix = Pi.xzxz;	vec4 iy = Pi.yyww;	vec4 fx = Pf.xzxz;	vec4 fy = Pf.yyww;	vec4 i = permute(permute(ix) + iy);	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;	vec4 gy = abs(gx) - 0.5;	vec4 tx = floor(gx + 0.5);	gx = gx - tx;	vec2 g00 = vec2(gx.x, gy.x);	vec2 g10 = vec2(gx.y, gy.y);	vec2 g01 = vec2(gx.z, gy.z);	vec2 g11 = vec2(gx.w, gy.w);	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));	g00 *= norm.x;	g01 *= norm.y;	g10 *= norm.z;	g11 *= norm.w;	float n00 = dot(g00, vec2(fx.x, fy.x));	float n10 = dot(g10, vec2(fx.y, fy.y));	float n01 = dot(g01, vec2(fx.z, fy.z));	float n11 = dot(g11, vec2(fx.w, fy.w));	vec2 fade_xy = fade(Pf.xy);	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);	return 2.3 * n_xy;}\n" },
	{ "\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * 1024 + gid.x;	colors[index] = vec4(gid.x / 1024.f, 0.f, gid.y / 1024.f, 1.f);}" },
	{ "\nlayout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;void main() {\n	uvec2 gid = gl_GlobalInvocationID.xy;	uint index = gid.y * 1024 + gid.x;	colors[index] = vec4(gid.x / 1024.f, 0.f, gid.y / 1024.f, 1.f);}" },
	{ "#define NEAR_Z 0.0f\n#define FAR_Z 250.0f\n#define STEP_SIZE 0.03f\nin vec2 p; /* screen position (-1, 1) */\nout vec3 oc;/**\n* Return camera origin given current time.\n*/\nvec3 camera_origin(){\n	return vec3(0, 25, 0);}\n/**\n* Return camera direction given current time.\n*/\nvec3 camera_direction(){\n	const float t = time * 0.1;	const float yaw = 1;	const float pitch = -0.5;	return vec3(-cos(pitch) * sin(yaw), sin(pitch), cos(pitch) * cos(yaw));}\n/**\n* Generate ray based on camera direction.\n*/\nvec3 generate_ray(vec3 dir){\n	vec3 u = vec3(0, 1, 0);	vec3 r = cross(u, dir);	return normalize(u * p.y + r * p.x + dir);}\n/**\n * Given a (x,z) coordinate it returns the height of the ocean.\n */\nfloat ocean_height(vec2 p){\n	return texture2D(texture0, p * 0.001).a;}\nbool terrainmarch(vec3 ro, vec3 rd, out vec3 hit, out float h){\n	for (float t = NEAR_Z; t < FAR_Z; t += STEP_SIZE){\n		const vec3 p = ro + rd*t;		h = ocean_height(p.xz);		if (p.y < h ){\n			hit = p;			return true;		}\n	}\n	return false;}\nvec3 sky_color(vec3 ro, vec3 rd){\n	const vec3 sky   = vec3(0.32, 0.58, 0.74);	const vec3 cloud = vec3(1.0, 0.95, 1.0);	const vec2 sc = ro.xz + rd.xz*(1000.0 - ro.y) / rd.y;	vec3 color = mix(sky * (1.0 - rd.y), cloud, 0.5*smoothstep(0.1f, 0.7f, cnoise(sc*0.001)));	return mix(color, sky, pow(1.0 - max(rd.y, 0.0), 8.0));}\nvec3 ocean_color(vec3 ro, vec3 rd, vec3 hit, float h){\n	return (texture2D(texture0, hit.xz * 0.001).rgb + 1.f) * 0.5;}\nvoid main() {\n	vec2 uv = (p + 1.)/2.;	vec3 d  = camera_direction();                             /* camera direction */\n	vec3 ro = camera_origin();                                /* ray origin */\n	vec3 rd = generate_ray(d);                                /* ray direction */\n	vec3 hit;	float h;	if (terrainmarch(ro, rd, hit, h)){\n		oc = ocean_color(ro, rd, hit, h);	} else {\n		oc = sky_color(ro, rd);	}\n	/*\n	vec2 x = uv*float(ocean_size);	vec2 index_v;	vec2 blend = modf(x, index_v);	ivec2 index = ivec2(index_v.x,index_v.y);	vec3 color = colors[index.y * ocean_size + index.x].rgb;	oc = color;	*/\n}" },
	{ "in float h;in vec3 n;out vec4 o;void main() {\n	o.rgb = n;	o.a = h;}" },
	{ "layout(location = 0) in vec4 v;layout(location = 1) in vec4 d; // ocean data\n// TODO: We could just use the depth as height\nout float h;out vec3 n;uniform mat4 p; // view projection matrix\nvoid main() {\n	gl_Position = p * v;	n = d.rgb;	h = d.a;}" },
	{ "layout (location=0) in vec2 ip;out vec2 p;out vec3 ro;out vec3 rd;void main(){\n	float speed = 1.;	if(time > 33.) speed = 2.;	if(time > 58.) speed = 5.;	if(time > 65.) speed = 7.;	\n	p = ip;	gl_Position =  vec4(ip, 0.0, 1.0);	vec3 r = gl_Position.xyz * vec3(1.78, 1.0, 0) + vec3(0, 0, -1);	ro = vec3(0, 0, -5+time*speed);	rd = vec3(r.x, r.y, -r.z);}" },
};
#pragma data_seg(pop)
