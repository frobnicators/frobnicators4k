#include "shaders.h"
#pragma data_seg(".shaders")
const struct shader_entry_t _shaders[NUM_SHADERS] = {
	{ "common.glsl" , "#version 150\n#extension GL_ARB_explicit_attrib_location:enable\nuniform float t,b;\nfloat scene(vec3 p, out vec3 c);vec3 lpos();float dbox(vec3 v,vec3 l,vec3 s){vec3 f=abs(l-v)-s;return max(f.x,max(f.y,f.z));}vec3 n_at(vec3 v){vec3 f,s;f.x=scene(v+vec3(.001,0,0),s)-scene(v-vec3(.001,0,0),s);f.y=scene(v+vec3(0,.001,0),s)-scene(v-vec3(0,.001,0),s);f.z=scene(v+vec3(0,0,.001),s)-scene(v-vec3(0,0,.001),s);return normalize(f);}vec3 light(vec3 v,vec3 s){vec3 f=v-lpos();float l=length(f);f=normalize(f);vec3 n=n_at(v);float y=max(dot(-f,n),0.);vec3 e=s*y*vec3(.8);return e+s*vec3(.2);}vec3 raymarch(vec3 v,vec2 f){vec3 s=vec3(0,0,0);s+=vec3(1,0,0)*f.x;s+=vec3(0,1,0)*f.y*.5625;s+=-vec3(0,0,1)*1;s=normalize(s);vec3 n;float l=0.;for(int r=0;r<500&&l<1000;r++){float y=scene(v,n);if(y<.001)return light(v,n);l+=abs(y);v+=s*y;}return vec3(0);}" },
	{ "intro" , "in vec2 p;in vec3 c;out vec3 oc;void main(){oc=raymarch(vec3(0,0,0),p);}float scene(vec3 v,out vec3 y){return y=vec3(.7,0,.7),v.x=mod(abs(v.x),vec3(50).x)-vec3(50).x*.5,v.y=mod(abs(v.y),vec3(50).y)-vec3(50).y*.5,v.z=mod(abs(v.z),vec3(50).z)-vec3(50).z*.5,dbox(v,vec3(25),vec3(40));}vec3 lpos(){return vec3(sin(t),0,cos(t))*50.;}" },
	{ "vertex.glsl" , "layout(location=0)in vec2 ip;out vec2 p;out vec3 c;void main(){p=ip,gl_Position=vec4(ip,0.,1.);}" },
};
