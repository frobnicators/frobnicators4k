#include "shaders.h"
#pragma data_seg(".shaders")
const struct shader_entry_t _shaders[NUM_SHADERS] = {
	{ "common.glsl" , "#version 150\n#extension GL_ARB_explicit_attrib_location:enable\nuniform float t,b;\nfloat scene(vec3 p, out vec3 c);vec3 lpos();float dbox(vec3 s,vec3 v,vec3 l){vec3 f=abs(v-s)-l;return max(f.x,max(f.y,f.z));}vec3 n_at(vec3 v){vec3 f,l;f.x=scene(v+vec3(.001,0,0),l)-scene(v-vec3(.001,0,0),l);f.y=scene(v+vec3(0,.001,0),l)-scene(v-vec3(0,.001,0),l);f.z=scene(v+vec3(0,0,.001),l)-scene(v-vec3(0,0,.001),l);return normalize(f);}float brdr(vec3 v,vec3 f,vec3 l,float s){float r=0;vec3 n=cross(f,l),e;float m=1.;for(int i=0;i<5;++i){float x=pow(float(i+1.),2.)*.07;r+=abs(scene(v+n*x,e)-s)*m;r+=abs(scene(v+n*-x,e)-s)*m;m*=.5;}return step(.1,r);}vec3 light(vec3 v,vec3 l,float f,vec3 s){vec3 r=v-lpos();float n=length(r);r=normalize(r);vec3 e=n_at(v);float m=max(dot(-r,e),0.);vec3 i=s*m*vec3(.8);float x=brdr(v,l,e,f);return mix(i+s*vec3(.2),vec3(0),x);}vec3 raymarch(vec3 v,vec2 f){vec3 l=vec3(0,0,0);l+=vec3(1,0,0)*f.x;l+=vec3(0,1,0)*f.y*.5625;l+=vec3(0,0,1)*1;l=normalize(l);vec3 e;float r=0.;for(int i=0;i<500&&r<1000;i++){float s=scene(v,e);if(s<.001)return light(v,l,s,e);r+=abs(s);v+=l*s;}return vec3(0);}" },
	{ "intro" , "in vec2 p;in vec3 c;out vec3 oc;void main(){oc=raymarch(vec3(0,0,t*10.),p);}float distance_sphere(vec3 v,vec3 y,float x){return length(v-y)-x;}float scene(vec3 v,out vec3 y){return y=vec3(.7,0,.7),v.x=mod(abs(v.x),vec3(50).x)-vec3(50).x*.5,v.y=mod(abs(v.y),vec3(50).y)-vec3(50).y*.5,v.z=mod(abs(v.z),vec3(50).z)-vec3(50).z*.5,dbox(v,vec3(25),vec3(40));}vec3 lpos(){return vec3(sin(t*2.)*2.,0,t-2.)*10.;}" },
	{ "vertex.glsl" , "layout(location=0)in vec2 ip;out vec2 p;out vec3 c;void main(){p=ip,gl_Position=vec4(ip,0.,1.);}" },
};
