#include "shaders.h"
#pragma data_seg(".shaders")
const struct shader_entry_t _shaders[NUM_SHADERS] = {
	{ "common.glsl" , "#version 150\n#extension GL_ARB_explicit_attrib_location:enable\nuniform float t,b;\nfloat scene(vec3 p, out vec3 c);vec3 lpos();float dbox(vec3 v,vec3 f,vec3 s){vec3 l=abs(f-v)-s;return max(l.x,max(l.y,l.z));}vec3 n_at(vec3 v){vec3 f,s;f.x=scene(v+vec3(.001,0,0),s)-scene(v-vec3(.001,0,0),s);f.y=scene(v+vec3(0,.001,0),s)-scene(v-vec3(0,.001,0),s);f.z=scene(v+vec3(0,0,.001),s)-scene(v-vec3(0,0,.001),s);return normalize(f);}float brdr(vec3 v,vec3 f,vec3 s,float l){float r=0;vec3 n=cross(f,s),e;float m=1.;for(int i=0;i<5;++i){float x=pow(float(i+1.),2.)*.07;r+=abs(scene(v+n*x,e)-l)*m;r+=abs(scene(v+n*-x,e)-l)*m;m*=.5;}return step(.1,r);}vec3 light(vec3 v,vec3 f,float s,vec3 n){vec3 l=v-lpos();float m=length(l);l=normalize(l);vec3 e=n_at(v);float i=max(dot(-l,e),0.);for(int r=0;r<10;++r){if(i<1./10*(r+1)){i=1./10*r;break;}}vec3 r=n*i*vec3(.8);float x=brdr(v,f,e,s);return mix(r+n*vec3(.2),vec3(0),x);}vec3 raymarch(vec3 v,vec2 s){vec3 f=vec3(0,0,0);f+=vec3(1,0,0)*s.x;f+=vec3(0,1,0)*s.y*.5625;f+=-vec3(0,0,1)*1;f=normalize(f);vec3 e;float r=0.;for(int i=0;i<500&&r<1000;i++){float l=scene(v,e);if(l<.001)return light(v,f,l,e);r+=abs(l);v+=f*l;}return vec3(0);}" },
	{ "intro" , "in vec2 p;in vec3 c;out vec3 oc;void main(){oc=raymarch(vec3(0,0,0),p);}float scene(vec3 v,out vec3 y){return y=vec3(.7,0,.7),v.x=mod(abs(v.x),vec3(50).x)-vec3(50).x*.5,v.y=mod(abs(v.y),vec3(50).y)-vec3(50).y*.5,v.z=mod(abs(v.z),vec3(50).z)-vec3(50).z*.5,dbox(v,vec3(25),vec3(40));}vec3 lpos(){return vec3(sin(t),0,cos(t))*50.;}" },
	{ "vertex.glsl" , "layout(location=0)in vec2 ip;out vec2 p;out vec3 c;void main(){p=ip,gl_Position=vec4(ip,0.,1.);}" },
};
